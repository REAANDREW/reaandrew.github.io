<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>https://reaandrew.github.io/posts/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <managingEditor>email@andrewrea.co.uk (Andy Rea)</managingEditor>
    <webMaster>email@andrewrea.co.uk (Andy Rea)</webMaster>
    <lastBuildDate>Thu, 24 Oct 2019 06:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://reaandrew.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Creating a Simple Stress Test Tool in Go Part 6</title>
      <link>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-6/</link>
      <pubDate>Thu, 24 Oct 2019 06:00:00 +0000</pubDate>
      <author>email@andrewrea.co.uk (Andy Rea)</author>
      <guid>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-6/</guid>
      <description>Must accept an argument to configure the number of simulated users To simulate multiple different concurrent virtual users this feature makes use of goroutines. Once the urls have been read into an array, a new goroutine is created for every virtual user according to the number specified in the configuration. To make sure the execution does not end immediately due to the use of goroutines I added in a Semaphore (in go sync.</description>
    </item>
    
    <item>
      <title>Creating a Simple Stress Test Tool in Go Part 5</title>
      <link>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-5/</link>
      <pubDate>Sun, 20 Oct 2019 12:00:00 +0000</pubDate>
      <author>email@andrewrea.co.uk (Andy Rea)</author>
      <guid>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-5/</guid>
      <description>Must accept an argument to read the urls sequentially or at random In siege one of the features was read the urls randomly using the -i flag which meant internet mode. I thought it would be a bit more intuitive if I used -r and --random for the long hand flags.
I did some refactoring in this iteration and one helper function I created was to simply how I created the test files with a list of url lines.</description>
    </item>
    
    <item>
      <title>Creating a Simple Stress Test Tool in Go Part 4</title>
      <link>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-4/</link>
      <pubDate>Sun, 20 Oct 2019 06:00:00 +0000</pubDate>
      <author>email@andrewrea.co.uk (Andy Rea)</author>
      <guid>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-4/</guid>
      <description>Must support http verbs GET,POST,PUT,DELETE I have added another use of the Cobra CLI for this feature so that I could support command line flags in the url list which must be provided to surge. Another reason was so that I was not parsing the commmand line arguments and flags by myself as that wheel is well and truly invented!
package client import ( &amp;#34;net/http&amp;#34; &amp;#34;github.com/spf13/cobra&amp;#34; ) type HttpCommand struct { } func (httpCommand HttpCommand) Execute(args []string) error { client := http.</description>
    </item>
    
    <item>
      <title>Creating a Simple Stress Test Tool in Go Part 3</title>
      <link>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-3/</link>
      <pubDate>Mon, 14 Oct 2019 06:00:00 +0000</pubDate>
      <author>email@andrewrea.co.uk (Andy Rea)</author>
      <guid>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-3/</guid>
      <description>Must accept a file arguement of urls to test For this feature I have added a file argument to the CLI configuration, with the value being passed to a new Application object. The CLI reposnsibility is to deal with the CLI context and not the logic of the application.
RootCmd.PersistentFlags().StringVarP(&amp;amp;urlFile, &amp;#34;urls&amp;#34;, &amp;#34;u&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;The urls file to use&amp;#34;) I have called the new struct Surge which will now be the main entry point of the actual application logic.</description>
    </item>
    
    <item>
      <title>Enumerating Github Repositories in Bash</title>
      <link>https://reaandrew.github.io/posts/enumerating-github-repositories-in-bash/</link>
      <pubDate>Mon, 19 Aug 2019 00:00:00 +0000</pubDate>
      <author>email@andrewrea.co.uk (Andy Rea)</author>
      <guid>https://reaandrew.github.io/posts/enumerating-github-repositories-in-bash/</guid>
      <description>I needed to get a list of all the repositories for a specific Github Organisation. Github limits the page size which you have use which ruled out a single call with a large value. I was also writing this routine in bash and less is more as they say.
My approach was very simplistic in that it simply tried an incrementing value for next page and if the response was empty then the end of the list had been reached.</description>
    </item>
    
    <item>
      <title>Creating a Simple Stress Test Tool in Go Part 2</title>
      <link>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-2/</link>
      <pubDate>Mon, 10 Jun 2019 20:22:20 +0000</pubDate>
      <author>email@andrewrea.co.uk (Andy Rea)</author>
      <guid>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-2/</guid>
      <description>Must be a CLI I chose the Cobra https://github.com/spf13/cobra package for the CLI since it is used by a lot of popular applications and it made things a lot simpler than working with the raw command line arguments, including testing etc&amp;hellip; In my opinion this is one of those decisions better made early so more focus can be given to the actual requirements. To get started I literally installed the generator and package with two separate go gets as per the documentation which created a default root command which I could build on.</description>
    </item>
    
    <item>
      <title>Creating a Simple Stress Test Tool in Go Part 1</title>
      <link>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-1/</link>
      <pubDate>Sun, 09 Jun 2019 14:43:46 +0000</pubDate>
      <author>email@andrewrea.co.uk (Andy Rea)</author>
      <guid>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-1/</guid>
      <description>Must be continually built and published to github releases supporting Windows, Linux and Mac The first part is to create a new repository and setup the continuous integration environment which I will use github and circleci for respectively. I will name the repository and the project surge. https://github.com/reaandrew/surge.git
To begin with I will create a simple hello world application to flush the pipeline with circleci.
package main import &amp;#34;fmt&amp;#34; func main() { fmt.</description>
    </item>
    
    <item>
      <title>Creating a Simple Stress Test Tool in Go - Requirements</title>
      <link>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go/</link>
      <pubDate>Sun, 09 Jun 2019 13:43:46 +0000</pubDate>
      <author>email@andrewrea.co.uk (Andy Rea)</author>
      <guid>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go/</guid>
      <description>One of the tools that has really stuck in my mind over the years is the siege stress test tool https://github.com/JoeDog/siege. It was really simple to use, give it a list of urls, add some command line arguments including concurrency, time etc&amp;hellip; and it would begin testing those urls with really clear output. At the end of the test run it would print out statistics for the entire test like requests per second, average response time etc&amp;hellip; One thing it also did was make a log of these statistics in tabular form in a file in the home directory which was really useful to compare performance against historical runs.</description>
    </item>
    
    <item>
      <title>Getting back into blogging with Hugo!</title>
      <link>https://reaandrew.github.io/posts/getting-back-into-blogging-with-hugo/</link>
      <pubDate>Sat, 08 Jun 2019 00:00:00 +0000</pubDate>
      <author>email@andrewrea.co.uk (Andy Rea)</author>
      <guid>https://reaandrew.github.io/posts/getting-back-into-blogging-with-hugo/</guid>
      <description>This is a first blog post whilst I get this site back up and running using Hugo.
The deployment option which I am using is the one where you use one github repository to store all the source and raw material and another github repository for the generated artefacts which are then published on github pages. There other ways of doing this (e.g. using a branch), which I tried, but I settled with the two repos approach.</description>
    </item>
    
  </channel>
</rss>