<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.58.3" />
    <title>Andy Rea</title>
    <link href="https://fonts.googleapis.com/css?family=Mansalva|Titillium+Web&display=swap" rel="stylesheet"> 
    <link rel="stylesheet" href="/css/bootstrap.min.css" >
    <link rel="stylesheet" href="/css/page.css" >
    <script src="/js/jquery-3.3.1.slim.min.js"></script>
    <script src="/js/popper.min.js"></script>
    <script src="/js/bootstrap.bundle.min.js"></script>
</head>
<body>
        <div class="container">
          <div class="row border-bottom mb-5">
            <div class="col2" id="header">
              <h1><a class="text-dark" href="/">Andy Rea</a></h1>
              <p>My thoughts on programming, scripting and cyber security</p>
            </div>
          </div>
          <div class="row">
            <div class="col" id="content">
  
    
    <h2><a class="text-dark" href="https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-3/">Creating a Simple Stress Test Tool in Go Part 3</a></h2>
    <p>Must accept a file arguement of urls to test For this feature I have added a file argument to the CLI configuration, with the value being passed to a new Application object. The CLI reposnsibility is to deal with the CLI context and not the logic of the application.
RootCmd.PersistentFlags().StringVarP(&amp;urlFile, &#34;urls&#34;, &#34;u&#34;, &#34;&#34;, &#34;The urls file to use&#34;) I have called the new struct Surge which will now be the main entry point of the actual application logic.</p>
    <p>October 14, 2019</p>
      
  
    
  
    
    <h2><a class="text-dark" href="https://reaandrew.github.io/posts/enumerating-github-repositories-in-bash/">Enumerating Github Repositories in Bash</a></h2>
    <p>I needed to get a list of all the repositories for a specific Github Organisation. Github limits the page size which you have use which ruled out a single call with a large value. I was also writing this routine in bash and less is more as they say.
My approach was very simplistic in that it simply tried an incrementing value for next page and if the response was empty then the end of the list had been reached.</p>
    <p>August 19, 2019</p>
      
  
    
    <h2><a class="text-dark" href="https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-2/">Creating a Simple Stress Test Tool in Go Part 2</a></h2>
    <p>Must be a CLI I chose the Cobra https://github.com/spf13/cobra package for the CLI since it is used by a lot of popular applications and it made things a lot simpler than working with the raw command line arguments, including testing etc&hellip; In my opinion this is one of those decisions better made early so more focus can be given to the actual requirements. To get started I literally installed the generator and package with two separate go gets as per the documentation which created a default root command which I could build on.</p>
    <p>June 10, 2019</p>
      
  
    
    <h2><a class="text-dark" href="https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-1/">Creating a Simple Stress Test Tool in Go Part 1</a></h2>
    <p>Must be continually built and published to github releases supporting Windows, Linux and Mac The first part is to create a new repository and setup the continuous integration environment which I will use github and circleci for respectively. I will name the repository and the project surge. https://github.com/reaandrew/surge.git
To begin with I will create a simple hello world application to flush the pipeline with circleci.
package main import &#34;fmt&#34; func main() { fmt.</p>
    <p>June 9, 2019</p>
      
  
    
    <h2><a class="text-dark" href="https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go/">Creating a Simple Stress Test Tool in Go - Requirements</a></h2>
    <p>One of the tools that has really stuck in my mind over the years is the siege stress test tool https://github.com/JoeDog/siege. It was really simple to use, give it a list of urls, add some command line arguments including concurrency, time etc&hellip; and it would begin testing those urls with really clear output. At the end of the test run it would print out statistics for the entire test like requests per second, average response time etc&hellip; One thing it also did was make a log of these statistics in tabular form in a file in the home directory which was really useful to compare performance against historical runs.</p>
    <p>June 9, 2019</p>
      
  
    
    <h2><a class="text-dark" href="https://reaandrew.github.io/posts/getting-back-into-blogging-with-hugo/">Getting back into blogging with Hugo!</a></h2>
    <p>This is a first blog post whilst I get this site back up and running using Hugo.
The deployment option which I am using is the one where you use one github repository to store all the source and raw material and another github repository for the generated artefacts which are then published on github pages. There other ways of doing this (e.g. using a branch), which I tried, but I settled with the two repos approach.</p>
    <p>June 8, 2019</p>
      
  

            </div>
          </div>
          <div class="row">
            <div class="col" id="footer">Copyright 2019 Andy Rea
</div>
          </div>
        </div>
    </body>
</html>
